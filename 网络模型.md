### 网络模型

程序使用Reactor事件驱动模型，使用多线程提高并发度。为避免线程频繁创建和销毁带来的开销，使用线程池，在程序的开始创建固定数量的线程。使用epoll作为IO多路复用的实现方式。

### 事件驱动模型

Reactor EventLoop 核心工作步骤：

**1.建立过程：**

首先建立一个EventLoop类，建立一个Channel类绑定到一个事件循环后调用更新函数，函数在EventLoop类中调用updateChannel()来更新poller中的事件表，到此一个事件就加入了EventLoop工作的流程中；

**2.执行过程：**

在Eventloop类中loop()函数中调用Poller类中的poll()来获取活跃事件，并总的记录在一个活跃事件表activeChannels中，之后遍历这个活跃事件表，逐个调用活跃事件Channel中的handleEvent()来回调事件函数。

在此中，EventLoop就是领导，Poller是书记员，Channel是打工仔，领导日常询问书记员（调用poll()），书记员找到有工作请求的打工仔（poll()中寻找活动的fd然后更新到活跃事件activeChannel中），执行官指导后就嘱咐打工仔干他对应的活（activeChannel->handleEvent()）

**3.runInLoop/queueInLoop：**	

走后门的runInLoop，在EventLoop中，领导人EventLoop专门设置了一个doPendingFunctor()环节，来额外接受不在poller记录本里面的事件，但还存在一个pendingFunctors_，专门记录额外事件名单，领导人EventLoop平常都会阻塞在poll()函数中但没事做，如果这是有额外事件提交（queueInLoop）了，就会weakup()（使用eventfd唤醒EventLoop线程）直接通知到poll()函数中，让EventLoop可以跳出poll()的阻塞，然后来doPendingFunctor()。

<img src="https://gitee.com/lalalilia/NetWordCode/raw/master/images/EventLoop工作步骤.jpg" style="zoom:50%;" />



#### 定时器Timer

Timer设计由三部分组成，

Timer.h/Timer.cpp 负责实现单个定时器Timer的信息储存，存储定时业务的需求；

TimerId.h 负责封装Timer类提供给用户；

TimerQueue.h/TimerQueue.cpp实现了TimerQueue类，使用timerfd创建定时器，注册 timerChannel，并注册到poller类维护的channel事件表中。

EventLoop中含有TimerQueue，并通过runInLoop的方式来创建定时器。



#### 缓冲Buffer类

<img src="https://gitee.com/lalalilia/NetWordCode/raw/master/images/缓冲buffer类.jpg" style="zoom:50%;" />

将一块内存空间分为3个部分，prepend，readable，writable；





#### 并发模型

<img src="https://gitee.com/lalalilia/NetWordCode/raw/master/images/并发模型.jpg" style="zoom:50%;" />

TcpServer只有一个，用于接受新连接，在接受到新连接之后，在线程池通过 Round-Robin 的方式从中获取EventLoop线程，并把TcpConnection分配给EventLoop线程，此时不用担心EventLoop正阻塞在poll() 函数中，因为使用runInLoop函数通过eventfd直接唤醒线程，进行来连接处理。

TcpConnection 可有多个，连接响应和传送消息可通过设置TcpServer回调函数实现，TcpConnection 有读写Channel，在必要时注册进Poller事件表。

