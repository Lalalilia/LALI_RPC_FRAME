//
// Created by lalalilia
//
#include <zrpc/stub/ClientStub.h>

// 存根程序主体
std::string clientStubTemplate(
        const std::string& macroName,
        const std::string& stubClassName,
        const std::string& procedureDefinitions,
        const std::string& notifyDefinitions)
{
    std::string str = R"(
/*
 * This stub is generated by zrpc, DO NOT modify it!
 */

#ifndef ZRPC_[macroName]_H
#define ZRPC_[macroName]_H

#include <jackson/Value.h>

#include <zrpc/util.h>
#include <zrpc/client/RpcClient.h>


class [stubClassName]
{
public:
    [stubClassName](EventLoop* loop, const InetAddress& serverAddress):
            client_(loop, serverAddress)
    {
        client_.setConnectionCallback([this](const TcpConnectionPtr& conn){
            if (conn->connected()) {
                conn_ = conn;
                cb_(conn_);
            }
            else {
                assert(conn_ != nullptr);
                cb_(conn_);
            }
        });
    }

    ~[stubClassName]() = default;

    void start() { client_.start(); }

    void setConnectionCallback(const ConnectionCallback& cb)
    {
        cb_ = cb;
    }

    [procedureDefinitions]
    [notifyDefinitions]

private:
    TcpConnectionPtr conn_;
    ConnectionCallback cb_;
    BaseClient client_;
};

#endif //ZRPC_[macroName]_H
)";
    replaceAll(str, "[macroName]", macroName);
    replaceAll(str, "[stubClassName]", stubClassName);
    replaceAll(str, "[procedureDefinitions]", procedureDefinitions);
    replaceAll(str, "[notifyDefinitions]", notifyDefinitions);
    return str;
}


std::string procedureDefineTemplate(
        const std::string& serviceName,
        const std::string& procedureName,
        const std::string& procedureArgs,
        const std::string& paramMembers)
{
    std::string str = R"(
void [procedureName]([procedureArgs] const ResponseCallback& cb)
{
    json::Value params(json::TYPE_OBJECT);
    [paramMembers]

    json::Value call(json::TYPE_OBJECT);
    call.addMember("jsonrpc", "2.0");
    call.addMember("method", "[serviceName].[procedureName]");
    call.addMember("params", params);

    assert(conn_ != nullptr);
    client_.sendCall(conn_, call, cb);
}
)";
    replaceAll(str, "[serviceName]", serviceName);
    replaceAll(str, "[procedureName]", procedureName);
    replaceAll(str, "[procedureArgs]", procedureArgs);
    replaceAll(str, "[paramMembers]", paramMembers);
    return str;
}


std::string notifyDefineTemplate(
        const std::string& serviceName,
        const std::string& notifyName,
        const std::string& notifyArgs,
        const std::string& paramMembers)
{
    std::string str = R"(
void [notifyName]([notifyArgs])
{
    json::Value params(json::TYPE_OBJECT);
    [paramMembers]

    json::Value notify(json::TYPE_OBJECT);
    notify.addMember("jsonrpc", "2.0");
    notify.addMember("method", "Hello.Goodbye");

    assert(conn_ != nullptr);
    client_.sendNotify(conn_, notify);
}
)";
    replaceAll(str, "[serviceName]", serviceName);
    replaceAll(str, "[notifyName]", notifyName);
    replaceAll(str, "[notifyArgs]", notifyArgs);
    replaceAll(str, "[paramMembers]", paramMembers);
    return str;
}

std::string paramMemberTemplate(const std::string& paramName)
{
    std::string str = R"(
params.addMember("[paramName]", [paramName]);
)";
    replaceAll(str, "[paramName]", paramName);
    return str;
}


std::string argTemplate(
        const std::string& argName,
        json::ValueType argType)
{
    std::string str = R"([argType] [argName])";
    auto typeStr = [=](){
        switch (argType) {
            case json::TYPE_INT32:
                return "int32_t";
            case json::TYPE_INT64:
                return "int64_t";
            case json::TYPE_DOUBLE:
                return "double";
            case json::TYPE_BOOL:
                return "bool";
            case json::TYPE_STRING:
                return "std::string";
            case json::TYPE_OBJECT:
            case json::TYPE_ARRAY:
                return "json::Value";
            default:
                assert(false && "bad arg type");
                return "bad type";
        }
    }();
    replaceAll(str, "[argType]", typeStr);
    replaceAll(str, "[argName]", argName);
    return str;
}

std::string ClientStub::getStub(){
    auto macroName = getMacroName();
    auto stubClassName = getStubClassName();
    auto procedureDefinitions = getProcedureDefinitions();
    auto notifyDefinitions = getNotifyDefinitions();

    return clientStubTemplate(macroName,
                              stubClassName,
                              procedureDefinitions,
                              notifyDefinitions);
}

std::string ClientStub::getMacroName() {
    std::string result = serviceInfo_.name;
    for (char& c: result)
        c = static_cast<char>(toupper(c));
    return result + "CLIENTSTUB";
}

std::string ClientStub::getStubClassName() {
    return serviceInfo_.name + "ClientStub";
}

std::string ClientStub::getProcedureDefinitions() {
    std::string result;

    auto& serviceName = serviceInfo_.name;

    for(auto& r:serviceInfo_.rpcReturn){
        auto& procedureName = r.name;
        auto procedureArgs = getGenericArgs(r,true);
        auto paramMembers = getGenericParamMembers(r);

        auto str = procedureDefineTemplate(
                serviceName,
                procedureName,
                procedureArgs,
                paramMembers
                );
        result.append(str);
    }
    return  result;
}


std::string ClientStub::getNotifyDefinitions(){
    std::string result;

    auto& serviceName = serviceInfo_.name;

    for (auto& r: serviceInfo_.rpcNotify) {
        auto& notifyName = r.name;
        auto notifyArgs = getGenericArgs(r, false);
        auto paramMembers = getGenericParamMembers(r);

        auto str = notifyDefineTemplate(
                serviceName,
                notifyName,
                notifyArgs,
                paramMembers);
        result.append(str);
    }
    return result;
}

template <typename Rpc>
std::string ClientStub::getGenericArgs(const Rpc &r, bool append) {
    std::string result;
    bool first = true;
    for(auto& p: r.params.getObject()){
        std::string one = argTemplate(p.key.getString(),
                                      p.value.getType());
        if(first)first = false;
        else result.append(", ");
        result.append(one);
    }
    if(append && !first)
        result.append(",");
    return  result;
}

template <typename Rpc>
std::string ClientStub::getGenericParamMembers(const Rpc &r) {
    std::string result;
    for(auto& p:r.params.getObject()){
        std::string one = paramMemberTemplate(p.key.getString());
        result.append(one);
    }
    return result;
}