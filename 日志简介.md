# 日志简介

**异步，双缓冲，批处理，**

日志文件包含：AsyncLogging.cpp/.h、FileUtil.cpp/.h、Logging.cpp/.h、LogFile.cpp/.h、Logstream.cpp/.h

多线程日志的要求，需要线程安全，即多个线程可并发的写日志；使用一个背景线程负责收集日志消息，并写入一个日志文件，其他线程只管往则会个日志线程发送日志消息，这称为异步日志。如果网络IO线程或者业务线程直接往磁盘里面写数据的话，写操作偶尔可能阻塞长达数秒之久，实时业务的处理流程应该要避免磁盘IO，特别是对于本网络库的 one loop per thread模型的非阻塞服务端程序中，因为线程是复用的，阻塞线程会影响多个连接。

每个线程都将消息写在一个缓冲区内，再单独使用一个消息线程来将缓冲区的消息写入到文件中。异步日志使用了两个缓冲区来完成日志的读写操作，两个缓冲区分为A和B，前端负责往buffer A中填写数据，后端负责把Buffer B中的数据写入磁盘中。当Buffer A写满之后，交换A和B，让后端将Buffer A的数据写入文件，而前端则往Buffer B中填入新的日志消息。使用两个buffer的好处就是新建日志消息的时候不用等待磁盘文件操作，避免每条新日志都触发了后端日志线程。所以，前端不是一条条的把日志消息传给后端，而是将多条日志消息集合在一起成一个大的buffer传送给后端，相当于批处理，减少了线程唤醒的频率。为了及时的将日志消息写入文件，buffer A没有满，日志库也会每3秒执行一次交换，将消息写入日志文件。

实际实现时会使用四个缓冲区，buffer A和buffer B里面会在细分两个缓冲区来辅助完成日志写入的操作；前端数据在写入时分为buffer和nextbuffer两块缓存，首先在currentbuffer中写入，如果currentbuffer写满了，会利用move让nextbuffer的空间给currentbuffer，之后唤醒后端开始将buffer写入日志文件；后端也申请了两个缓冲区，用于在临界区中将填充前端的cur和next的空间；

AsyncLogging 是核心，负责启动一个 log 线程，专门用来将 log 写入 logfile，使用双缓冲技术，写入时机可能是定时时间到达或者缓冲区填满；

FileUtil 是最底层的文件类，封装了log文件的、写入并在类析构的时候关闭文件，底层使用了标准IO，该文件的 append 函数直接向文件写；

LogFile 进一步 封装了FileUtil，实现自动滚动，设置了一个循环次数，每过这么多次就会flush一次；

LogStream 主要用来格式化输出，重载了<<运算符，同时也有自己的一块缓冲区，这里的缓冲区是为了缓存一行，把多个<<的结果连成一块；

Logging 是对外接口，Logging 类内涵一个 LogStream 对象，主要是为了每次打 log 的时候在 log 之前和之后加上固定的格式化信息，比如打 log 的行，文件名等信息；同时再 Logging 中使用了 pimpl 的技法，可以降低接口的耦合性，屏蔽掉了接口的具体实现方式，还可以降低头文件之间的依赖关系，降低编译时间。

